services:
  web:
    image: new_project:latest
    container_name: newproject_web_prod
    # No bind mounts: all data/models baked inside image
    # Expose only to the internal network; Caddy handles public 80/443
    expose:
      - "8000"
    environment:
      - PYTHONUNBUFFERED=1
      - API_KEY=${API_KEY:-}
      - RATE_LIMIT_PER_MIN=200
    restart: unless-stopped
    # Healthcheck comes from Dockerfile
    networks:
      - webnet

  # Automatic HTTPS reverse proxy
  caddy:
    image: caddy:2-alpine
    container_name: newproject_caddy
    depends_on:
      - web
    ports:
      - "80:80"
      - "443:443"
    environment:
      # These are read inside the Caddyfile using {$VAR} placeholders
      - DOMAIN=${DOMAIN}
      - ACME_EMAIL=${ACME_EMAIL:-}
    volumes:
      - ./infra/caddy/conf/Caddyfile:/etc/caddy/Caddyfile:ro
      - ./infra/caddy/data:/data
      - ./infra/caddy/config:/config
    restart: unless-stopped
    networks:
      - webnet

  # Optional Dynamic DNS updater (disabled by default; enable by setting DDNS_PROVIDER in .env and running compose)
  ddns:
    image: python:3.11-slim
    container_name: newproject_ddns
    restart: unless-stopped
    profiles: ["ddns"]
    env_file:
      - .env
    working_dir: /app
    volumes:
      - ./scripts/ddns:/app:ro
    command:
      - sh
      - -c
      - set -e; python -m pip install -q requests; python -u ddns_updater.py
    networks:
      - webnet

networks:
  webnet:
    driver: bridge

volumes: {}

# Usage:
# 1) Build the image with artifacts baked in:
#    PowerShell:
#      $sha = git rev-parse --short HEAD; $ts = (Get-Date -Format o)
#      docker build --build-arg APP_GIT_SHA=$sha --build-arg APP_BUILD_TIME=$ts -t new_project:$sha -t new_project:latest .
# 2) Create a DNS A record for your domain -> <server public IP>
# 3) Create a .env with DOMAIN=your.domain.com and ACME_EMAIL=you@example.com
# 4) Run: docker compose -f docker-compose.prod.yml up -d
# 5) Verify: https://<your domain>/health

# DDNS (DuckDNS/Cloudflare) notes:
# - DDNS service runs only if you specify --profile ddns, e.g.:
#     docker compose -f docker-compose.prod.yml --profile ddns up -d
# - To force a fixed IP (no auto-detection), set in .env:
#     DDNS_PROVIDER=duckdns
#     DUCKDNS_DOMAIN=your-subdomain
#     DUCKDNS_TOKEN=your-token
#     DDNS_STATIC_IP=1.2.3.4   # your fixed public IP
#     DDNS_ONESHOT=true         # optional: run once then exit
# - If you don't need DDNS at all (your IP is static and DNS A record is fixed), just do not use the ddns profile.
