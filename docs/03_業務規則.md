# 03 業務規則

## 核心業務邏輯

### 1. 預測邏輯

#### 1.1 預測流程

```
用戶請求 (GET /api/draw?model=rf&symbol=AAPL)
       │
       ▼
  載入目標股票 CSV
       │
       ▼
  提取最新一行資料
       │
       ▼
  載入預訓練模型 (pipeline + threshold)
       │
       ▼
  特徵對齊 (確保特徵順序與訓練時一致)
       │
       ▼
  特徵填充 (缺失值使用中位數)
       │
       ▼
  模型推理 (predict_proba)
       │
       ▼
  閾值判斷 (proba >= threshold → 漲)
       │
       ▼
  回傳結果 (label: "漲/跌", proba: 0.65)
```

#### 1.2 預測規則

**規則 1：僅推理模式**
- 生產環境禁止在線訓練
- 必須預先訓練好模型檔案（`*_pipeline.pkl`, `*_threshold.pkl`）
- 模型檔案通過掛載或烤入鏡像方式提供

**規則 2：模型選擇**
- 支持兩種模型：`rf` (隨機森林) 和 `lr` (邏輯迴歸)
- 預設使用隨機森林（準確率通常更高）

**規則 3：特徵對齊**
- 推理時自動檢查特徵列表是否與訓練時一致
- 缺失特徵自動填充爲 0（避免推理失敗）
- 順序必須與訓練時完全一致

**規則 4：閾值應用**
- 模型輸出概率 P(y=1)（上漲概率）
- 當 P(y=1) >= threshold 時，預測標籤爲 "漲"
- 當 P(y=1) < threshold 時，預測標籤爲 "跌"
- 閾值範圍：0.30 - 0.70（典型值約 0.50 - 0.60）

**規則 5：資料新鮮度**
- 推理基於最新一行資料（最近交易日）
- 若 CSV 資料過舊（如超過 1 周未更新），建議拒絕推理或警告

#### 1.3 預測輸出格式

```json
{
  "ok": true,
  "model": "rf",
  "threshold": 0.55,
  "proba": 0.6523,
  "label": "漲",
  "fortune": {
    "title": "預測結果",
    "text": [
      "模型：rf",
      "預測：漲",
      "預測機率：65.23%"
    ],
    "label": "漲",
    "prob_up": 0.6523,
    "threshold": 0.55,
    "confidence": 0.85,
    "advice": "此籤僅供參考，請謹慎投資"
  },
  "symbol": "AAPL",
  "csv": "/path/to/AAPL_short_term_with_lag3.csv"
}
```

---

### 2. 資料建置邏輯

#### 2.1 單股票建置流程

```
用戶請求 (GET /api/build_symbol?symbol=AAPL)
       │
       ▼
  檢查 symbol 是否爲空
       │
       ▼
  規範化 symbol (如 2330 → 2330.TW)
       │
       ▼
  調用 Yahoo Finance API 獲取歷史資料
       │
       ▼
  計算技術指標 (MA, 報酬率, Gap 等)
       │
       ▼
  生成滯後特徵 (lag 1-5)
       │
       ▼
  資料清洗 (dropna, Winsorization)
       │
       ▼
  儲存爲 CSV (data/{symbol}_short_term_with_lag3.csv)
       │
       ▼
  記錄更新時間 (data/{symbol}_last_update.txt)
       │
       ▼
  回傳成功回應
```

#### 2.2 批量建置流程

```
用戶請求 (GET /api/bulk_build_start?index=sp500&concurrency=4)
       │
       ▼
  獲取指數成分列表 (如 S&P 500)
       │
       ▼
  建立批量任務記錄 (task_id, total, done=0)
       │
       ▼
  啟動非同步工作器 (_bulk_build_worker)
       │
       ▼
  並發建置 (使用 Semaphore 控制並發度)
       │
       ├──> Symbol 1 → 建置 CSV
       ├──> Symbol 2 → 建置 CSV
       ├──> Symbol 3 → 建置 CSV
       └──> ...
       │
       ▼
  更新任務進度 (done++, errors 記錄失敗項)
       │
       ▼
  所有完成後標記任務狀態爲 "completed"
```

**並發控制規則**：
- 預設並發度：4
- 可通過 `concurrency` 參數調整（範圍 1-20）
- 過高並發可能導致 Yahoo Finance 速率限制

**失敗處理**：
- 單個 symbol 失敗不影響整體任務
- 失敗信息記錄在 `task.errors` 字典中
- 用戶可查詢進度端點獲取失敗列表

#### 2.3 指數成分獲取規則

**S&P 500**：
- 資料源：Wikipedia (https://en.wikipedia.org/wiki/List_of_S%26P_500_companies)
- 解析方式：`pd.read_html()` 讀取表格第一欄 "Symbol"
- 符號替換：`.` → `-` (如 `BRK.B` → `BRK-B`)

**Nasdaq-100**：
- 資料源：Wikipedia (https://en.wikipedia.org/wiki/Nasdaq-100)
- 解析方式：`pd.read_html()` 尋找包含 "Ticker" 或 "Symbol" 列的表格

**臺股 (TWSE)**：
- 資料源：預定義列表（暫無公開 API）
- 預設樣本：`['2330', '2317', '2454', '2412']`
- 可擴展爲完整臺股成分

---

### 3. 自動更新邏輯

#### 3.1 單股票自動更新 (Symbol Loop)

**觸發條件**：
- 用戶顯式調用 `/api/auto/start_symbol?symbol=AAPL&interval=5`

**執行流程**：
```python
while True:
    try:
        # 建置最新資料
        build_csv(symbol)
        # 重置失敗計數
        consecutive_failures = 0
        # 按基礎間隔休眠
        sleep_time = interval_min
    except Exception:
        # 記錄失敗
        consecutive_failures += 1
        # 指數退避
        sleep_time = min(
            max_backoff_min,
            interval_min * (backoff_factor ** consecutive_failures)
        )
    
    await asyncio.sleep(sleep_time * 60)
```

**退避策略**：
- 預設退避因子：2.0
- 最大退避時間：30 分鐘
- 範例：連續失敗 3 次 → `5 * (2 ** 3) = 40 分鐘` → 上限 30 分鐘

**持久化**：
- 啟動時將配置寫入 `auto_registry.json`
- 服務重啓後自動復原（基於 registry）

#### 3.2 指數批量更新 (Index Loop)

**與 Symbol Loop 的區別**：
- Symbol Loop：爲每個股票建立獨立協程
- Index Loop：單一協程批量更新整個指數成分

**適用場景**：
- Symbol Loop：少於 10 個關鍵股票
- Index Loop：50-500 個大量股票

**執行流程**：
```python
while True:
    try:
        # 獲取指數成分列表
        symbols = fetch_index_tickers(index)
        
        # 動態合併現有 CSV symbols
        existing = list_existing_csv_symbols()
        symbols = merge_unique(symbols, existing)
        
        # 並發建置（使用 Semaphore 限制並發度）
        async with Semaphore(concurrency):
            for symbol in symbols:
                build_csv(symbol)
        
        # 成功則重置退避
        consecutive_failures = 0
        sleep_time = interval_min
    except Exception:
        consecutive_failures += 1
        sleep_time = min(
            max_backoff_min,
            interval_min * (backoff_factor ** consecutive_failures)
        )
    
    await asyncio.sleep(sleep_time * 60)
```

**動態合併規則**（Feature C）：
- 每輪開始前掃描 `data/` 目錄
- 發現新的 `*_short_term_with_lag3.csv` 檔案
- 提取 symbol 並加入更新列表
- 用途：支持離線建置後自動納入循環更新

#### 3.3 批量啟動現有 CSV (Feature A)

**觸發條件**：
- 用戶調用 `/api/auto/start_existing_csvs?interval=5`

**執行流程**：
```
掃描 data/ 目錄
       │
       ▼
  提取所有 *_short_term_with_lag3.csv 檔案名
       │
       ▼
  解析 symbol (如 AAPL_short_term_with_lag3.csv → AAPL)
       │
       ▼
  爲每個 symbol 啟動 Symbol Loop
       │
       ▼
  將配置寫入 auto_registry.json
```

**適用場景**：
- 已通過批量任務建置大量 CSV
- 希望爲所有現有股票啟動自動更新

**注意事項**：
- 可能一次性啟動數百個協程（資源消耗大）
- 大量股票建議改用 Index Loop

---

### 4. 模型訓練規則

#### 4.1 資料切分規則

```python
# 時間序列切分（避免資料洩漏）
TEST_SPLIT = 0.2      # 測試集佔比
VAL_SPLIT = 0.2       # 驗證集佔比（從訓練集中劃分）

# 範例：1000 行資料
total = 1000
test_idx = int(total * (1 - TEST_SPLIT))  # 800
train = data[:test_idx]  # 前 800 行
test = data[test_idx:]   # 後 200 行

val_idx = int(len(train) * (1 - VAL_SPLIT))  # 640
core = train[:val_idx]   # 前 640 行（核心訓練集）
val = train[val_idx:]    # 後 160 行（驗證集）
```

**設計理由**：
- 時間序列資料不能隨機打亂（會引入未來信息洩漏）
- 驗證集用於閾值最佳化
- 測試集用於最終效能評估

#### 4.2 標籤篩選規則

```python
THRESH = 0.01  # 1% 漲跌幅閾值

# 計算明天收益率
ret1 = (明天收盤價 - 今天收盤價) / 今天收盤價

# 三分類別標籤生成
if ret1 > THRESH:
    y = 1          # 明確上漲
elif ret1 < -THRESH:
    y = 0          # 明確下跌
else:
    y = NaN        # 篩選噪聲（小幅波動）

# 訓練時移除 NaN 標籤行
X_train = X[~y.isna()]
y_train = y[~y.isna()]
```

**設計理由**：
- 篩選小幅波動的噪聲樣本
- 提高模型對明確信號的敏感度
- 減少訓練樣本但提升有效性

#### 4.3 閾值最佳化規則

```python
def optimize_threshold(model, X_val, y_val):
    # 網格搜尋範圍
    grid = np.linspace(0.30, 0.70, 41)
    
    best_threshold = 0.5
    best_f1 = -1.0
    
    # 獲取驗證集預測概率
    proba = model.predict_proba(X_val)[:, 1]
    
    # 遍歷所有候選閾值
    for t in grid:
        y_pred = (proba >= t).astype(int)
        f1 = f1_score(y_val, y_pred, average='weighted')
        
        if f1 > best_f1:
            best_f1 = f1
            best_threshold = t
    
    return best_threshold, best_f1
```

**設計理由**：
- 預設閾值 0.5 不一定最優
- 基於驗證集 F1-score 最佳化（平衡精確率和召回率）
- 使用 weighted average（考慮類別別不平衡）

#### 4.4 模型超參數

**隨機森林 (RandomForestClassifier)**：
```python
{
    'n_estimators': 400,           # 樹的數量
    'max_depth': 4,                # 樹的最大深度（防止過擬合）
    'min_samples_leaf': 20,        # 葉節點最小樣本數
    'min_samples_split': 10,       # 分裂所需最小樣本數
    'max_features': 'sqrt',        # 每次分裂考慮的特徵數
    'class_weight': 'balanced',    # 自動處理類別別不平衡
    'random_state': 42,            # 隨機種子（可復現）
    'n_jobs': -1                   # 使用所有 CPU 核心
}
```

**邏輯迴歸 (LogisticRegression)**：
```python
{
    'max_iter': 1000,              # 最大迭代次數
    'class_weight': 'balanced',    # 自動處理類別別不平衡
    'n_jobs': -1                   # 使用所有 CPU 核心
}
```

---

### 5. 特殊業務規則

#### 5.1 臺股符號規範化

**規則**：
- 輸入：純數字（如 "2330"）
- 輸出：添加 `.TW` 後綴（如 "2330.TW"）
- 原因：Yahoo Finance API 要求臺股使用 `.TW` 後綴

**程式碼實作**：
```python
def normalize_tw_ticker(symbol: str) -> str:
    if symbol.isdigit():
        return f"{symbol}.TW"
    return symbol
```

#### 5.2 缺失值填充規則

**訓練時**：
- 使用訓練集的中位數（median）填充
- 儲存 scaler 的狀態（包含中位數）

**推理時**：
- 使用訓練時儲存的中位數填充
- 確保與訓練時的分佈一致

**程式碼實作**：
```python
# 訓練時
medians = X_train.median(numeric_only=True)
X_train = X_train.fillna(medians)

# 推理時
X_inference = X_inference.fillna(medians)
```

#### 5.3 例外值處理規則（Winsorization）

**應用列**：
- 報酬率％
- Gap％
- 振幅％
- MA5差％
- MA20差％
- 成交量(千股)_rel20％

**處理方式**：
```python
def winsorize(df, cols, lower=0.01, upper=0.99):
    for col in cols:
        q_low = df[col].quantile(lower)
        q_high = df[col].quantile(upper)
        df[col] = df[col].clip(lower=q_low, upper=q_high)
    return df
```

**設計理由**：
- 移除極端例外值（如閃崩、暴漲）
- 保留 1%-99% 分位數內的資料
- 減少極端值對模型的影響

#### 5.4 最新資料可用性規則

**推理條件**：
- CSV 檔案必須存在
- CSV 檔案至少包含 1 行資料
- 最新行不能全爲 NaN

**拒絕推理場景**：
- CSV 檔案不存在 → 回傳 404
- CSV 檔案爲空 → 回傳 500
- 模型檔案缺失 → 回傳 404

---

## 邊界條件

### 1. 資料邊界

| 邊界條件 | 處理方式 | 範例 |
|----------|----------|------|
| 歷史資料不足 | 最少 30 天資料才能建置 | < 30 行 → 拒絕 |
| 單日資料缺失 | 使用前值填充（forward fill） | 假期資料缺失 |
| 連續多日缺失 | 拒絕建置該股票 | 停牌超過 7 天 |
| 負數價格 | 拒絕建置該股票 | 資料錯誤 |
| 零成交量 | 保留該行（可能爲輕量交易） | 允許 volume=0 |

### 2. 模型邊界

| 邊界條件 | 處理方式 | 範例 |
|----------|----------|------|
| 模型檔案缺失 | 回傳 404 錯誤 | 未訓練或檔案丟失 |
| 特徵數量不匹配 | 自動填充缺失特徵爲 0 | 新特徵未在訓練集出現 |
| 特徵順序不匹配 | 重新排序以匹配訓練時順序 | 列順序改變 |
| 閾值檔案缺失 | 使用預設閾值 0.5 | threshold.pkl 丟失 |
| 推理輸入全爲 NaN | 回傳 500 錯誤 | 資料品質問題 |

### 3. 任務邊界

| 邊界條件 | 處理方式 | 範例 |
|----------|----------|------|
| 批量任務已存在 | 拒絕建立新任務 | task_id 衝突 |
| 符號列表爲空 | 回傳 400 錯誤 | symbols="" |
| 並發度超限 | 自動限制爲最大值 20 | concurrency=100 → 20 |
| 單股票重複啟動 | 跳過已啟動的任務 | AAPL loop 已執行 |
| 指數成分獲取失敗 | 重試 3 次後回傳錯誤 | Wikipedia 不可用 |

### 4. 網路邊界

| 邊界條件 | 處理方式 | 範例 |
|----------|----------|------|
| Yahoo Finance 超時 | 重試 3 次，間隔 5 秒 | 網路不穩定 |
| 速率限制（429） | 指數退避重試 | 短時間內請求過多 |
| DNS 解析失敗 | 記錄錯誤，不重試 | 網路配置問題 |
| 連線拒絕 | 記錄錯誤，稍後重試 | 服務暫時不可用 |

---

## 業務約束

### 1. 時間約束

- **資料新鮮度**：推理資料應在 1 周內
- **更新間隔**：單股票最小更新間隔 1 分鐘
- **批量任務超時**：單個批量任務最長 2 小時

### 2. 資源約束

- **並發度限制**：最大並發 20（防止 OOM）
- **記憶體限制**：單實例建議 2 GB（500 檔股票）
- **磁盤限制**：CSV 檔案總大小預估 500 MB（1000 檔）

### 3. 準確性約束

- **模型準確率**：驗證集 F1-score > 0.55 才部署
- **閾值範圍**：0.30 - 0.70（超出範圍拒絕）
- **特徵缺失率**：推理時特徵缺失率 > 50% 拒絕

---

## 相關文檔

- [01_架構概覽.md](./01_架構概覽.md) - 系統架構與技術棧
- [02_資料模型.md](./02_資料模型.md) - 核心資料結構
- [04_術語詞彙.md](./04_術語詞彙.md) - 統一術語與命名約定
- [05_開發規範.md](./05_開發規範.md) - 程式碼風格與開發流程
