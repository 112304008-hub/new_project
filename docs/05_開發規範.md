# 05 開發規範

## 程式碼風格

### 1. Python 程式碼風格（PEP 8）

#### 1.1 縮進與空格

```python
# 使用 4 個空格縮進（不使用 Tab）
def predict(csv_path, model):
    if model == "rf":
        return run_rf_model()
    else:
        return run_lr_model()

# 函式參數過長時換行對齊
def build_from_yfinance(
    symbol: str,
    out_csv: Path,
    start: str = "2020-01-01",
    expected_features: Optional[list] = None
) -> pd.DataFrame:
    pass
```

#### 1.2 行長度限制

```python
# 每行最多 120 字符（推薦 100 字符）
# 過長的字符串或鏈式調用需要換行

# ❌ 不推薦
result = model.predict_proba(X_test.fillna(medians).iloc[[-1]])[0][1]

# ✅ 推薦
X_latest = X_test.fillna(medians).iloc[[-1]]
proba = model.predict_proba(X_latest)[0][1]
```

#### 1.3 空行規則

```python
# 頂層函式和類別之間空 2 行
def function_one():
    pass


def function_two():
    pass


class MyClass:
    pass


# 類別內方法之間空 1 行
class MyClass:
    def method_one(self):
        pass

    def method_two(self):
        pass
```

#### 1.4 導入規範

```python
# 導入順序：標準庫 > 第三方庫 > 本地模塊
# 每組之間空 1 行

# 標準庫
import os
import time
from pathlib import Path
from typing import Dict, Optional, Union

# 第三方庫
import pandas as pd
import numpy as np
from fastapi import FastAPI, Request
from sklearn.ensemble import RandomForestClassifier

# 本地模塊
from stock import predict, train
```

#### 1.5 類型標註（Type Hints）

```python
# 函式簽名添加類型標註
def predict(
    csv_path: Optional[Union[str, Path]] = None,
    model: Literal["rf", "lr"] = "rf",
    symbol: Optional[str] = None
) -> Dict[str, Any]:
    pass

# 變數類型標註（複雜類型）
SYMBOL_TASKS: Dict[str, asyncio.Task] = {}
BULK_TASKS: Dict[str, Dict] = {}
```

---

### 2. 命名規範

#### 2.1 變數命名

```python
# ✅ 清晰的描述性名稱
consecutive_failures = 0
backoff_factor = 2.0
symbol_csv_path = Path("data/AAPL_short_term_with_lag3.csv")

# ❌ 模糊的縮寫
cf = 0
bf = 2.0
scp = Path("data/AAPL_short_term_with_lag3.csv")
```

#### 2.2 函式命名

```python
# ✅ 動詞開頭，表達功能
def build_from_yfinance(symbol: str):
    pass

def normalize_tw_ticker(symbol: str) -> str:
    pass

def optimize_threshold(model, X_val, y_val):
    pass

# ❌ 模糊的名稱
def process(symbol: str):
    pass

def handle(symbol: str):
    pass
```

#### 2.3 布爾變數命名

```python
# ✅ is_, has_, can_, should_ 開頭
is_valid = True
has_model = check_model_exists()
can_predict = data_ready and model_ready
should_retry = error_count < MAX_RETRIES

# ❌ 模糊的布爾名稱
valid = True
model = check_model_exists()
```

---

### 3. 註釋規範

#### 3.1 模塊文檔字符串

```python
"""
main.py - FastAPI 應用主模塊

功能概述：
- HTTP 請求處理與路由
- 中間件管理（日誌、限流、鑑權）
- 後臺任務調度（Symbol Loop, Index Loop）
- 監控指標導出（Prometheus）

作者：開發團隊
版本：1.0.0
最後更新：2024-01-15
"""
```

#### 3.2 函式文檔字符串（Google 風格）

```python
def predict(csv_path: Optional[Union[str, Path]] = None,
            model: Literal["rf", "lr"] = "rf",
            symbol: Optional[str] = None) -> Dict[str, Any]:
    """執行模型推理並回傳預測結果。

    Args:
        csv_path: CSV 檔案路徑。若爲 None，則使用預設路徑
        model: 模型類型。可選 "rf"（隨機森林）或 "lr"（邏輯迴歸）
        symbol: 股票程式碼。若提供，將優先使用對應的 CSV 檔案

    Returns:
        包含預測結果的字典，鍵包括：
        - label: 預測標籤（"漲" 或 "跌"）
        - proba: 上漲概率（0-1）
        - threshold: 分類別閾值
        - model: 使用的模型類型
        - csv: 實際使用的 CSV 路徑

    Raises:
        FileNotFoundError: CSV 檔案不存在
        RuntimeError: 模型檔案缺失或推理失敗

    Examples:
        >>> result = predict(model="rf", symbol="AAPL")
        >>> print(result["label"])
        '漲'
        >>> print(result["proba"])
        0.6523
    """
```

#### 3.3 行內註釋

```python
# ✅ 解釋爲什麼這樣做（Why）
# 使用指數退避策略避免 Yahoo Finance 速率限制
sleep_time = interval * (backoff_factor ** failures)

# ❌ 重複程式碼邏輯（What）
# 計算睡眠時間
sleep_time = interval * (backoff_factor ** failures)

# ✅ 標註重要決策點
# 必須使用時間序列切分，避免資料洩漏
test_idx = int(len(data) * (1 - TEST_SPLIT))
```

---

## 例外處理

### 1. 例外處理原則

#### 1.1 具體例外優先

```python
# ✅ 捕獲具體例外
try:
    df = pd.read_csv(csv_path)
except FileNotFoundError:
    logger.error(f"CSV 檔案不存在: {csv_path}")
    return {"error": "檔案不存在"}
except pd.errors.EmptyDataError:
    logger.error(f"CSV 檔案爲空: {csv_path}")
    return {"error": "檔案爲空"}
except Exception as e:
    logger.exception(f"讀取 CSV 失敗: {e}")
    return {"error": "未知錯誤"}

# ❌ 過於寬泛的例外捕獲
try:
    df = pd.read_csv(csv_path)
except Exception:
    return {"error": "失敗"}
```

#### 1.2 例外鏈保留

```python
# ✅ 保留原始例外信息
try:
    pipeline = joblib.load(model_path)
except FileNotFoundError as e:
    raise RuntimeError(f"模型檔案缺失: {model_path}") from e

# ❌ 丟失原始例外
try:
    pipeline = joblib.load(model_path)
except FileNotFoundError:
    raise RuntimeError("模型載入失敗")
```

#### 1.3 資源清理（上下文管理器）

```python
# ✅ 使用 with 語句自動清理資源
with open(csv_path, 'r', encoding='utf-8') as f:
    data = f.read()

# ✅ 非同步上下文管理器
async with Semaphore(concurrency):
    await build_symbol(symbol)

# ❌ 手動管理資源（容易遺漏）
f = open(csv_path, 'r')
data = f.read()
f.close()
```

### 2. 錯誤回應規範

#### 2.1 API 錯誤回應

```python
# ✅ 統一的錯誤回應格式
from fastapi.responses import JSONResponse

@app.get('/api/draw')
def draw(symbol: str):
    if not symbol:
        return JSONResponse(
            {
                "error": "請提供 symbol 參數",
                "code": "MISSING_PARAMETER",
                "suggestion": "範例：?symbol=AAPL"
            },
            status_code=400
        )
```

#### 2.2 日誌記錄

```python
# ✅ 記錄完整的例外棧
try:
    result = predict(csv_path, model)
except Exception as e:
    logger.exception(f"預測失敗 symbol={symbol} model={model}")
    return {"error": str(e)}

# ❌ 僅記錄錯誤消息（丟失棧信息）
try:
    result = predict(csv_path, model)
except Exception as e:
    logger.error(str(e))
    return {"error": str(e)}
```

---

## 測試規範

### 1. 單元測試

#### 1.1 測試檔案組織

```
tests/
├── __init__.py
├── conftest.py              # pytest fixtures
├── test_main.py             # 測試 main.py
├── test_stock.py            # 測試 stock.py
└── test_tasks_and_safety.py # 測試後臺任務
```

#### 1.2 測試函式命名

```python
# test_<模塊名>.py
def test_predict_with_valid_symbol():
    """測試正常股票程式碼的預測"""
    result = predict(symbol="AAPL", model="rf")
    assert result["label"] in ["漲", "跌"]
    assert 0 <= result["proba"] <= 1

def test_predict_with_missing_csv():
    """測試 CSV 檔案缺失時的例外處理"""
    with pytest.raises(FileNotFoundError):
        predict(symbol="INVALID", model="rf")

def test_normalize_tw_ticker():
    """測試臺股程式碼規範化"""
    assert normalize_tw_ticker("2330") == "2330.TW"
    assert normalize_tw_ticker("AAPL") == "AAPL"
```

#### 1.3 使用 Fixtures

```python
# conftest.py
import pytest
from pathlib import Path

@pytest.fixture
def tmp_csv_path(tmp_path):
    """建立臨時 CSV 檔案"""
    csv_path = tmp_path / "test_data.csv"
    pd.DataFrame({
        "年月日": ["2024-01-01"],
        "收盤價(元)": [100.0]
    }).to_csv(csv_path, index=False)
    return csv_path

# test_stock.py
def test_predict_with_tmp_csv(tmp_csv_path):
    """使用臨時 CSV 測試預測功能"""
    result = predict(csv_path=tmp_csv_path, model="rf")
    assert result is not None
```

#### 1.4 Mock 外部依賴

```python
def test_bulk_build_with_mock(client, monkeypatch):
    """測試批量建置任務（Mock Yahoo Finance）"""
    def fake_build(symbol: str, out_csv: Path):
        # 模擬資料建置，不實際調用 API
        pd.DataFrame({"col": [1]}).to_csv(out_csv, index=False)
    
    monkeypatch.setattr("main._build_from_yfinance", fake_build)
    
    response = client.get("/api/bulk_build_start?symbols=AAPL,MSFT")
    assert response.status_code == 200
    assert "task_id" in response.json()
```

### 2. 整合測試

```python
# test_integration.py
def test_end_to_end_prediction(client):
    """端到端測試：建置 -> 預測"""
    # 1. 建置資料
    build_resp = client.get("/api/build_symbol?symbol=AAPL")
    assert build_resp.status_code == 200
    
    # 2. 執行預測
    pred_resp = client.get("/api/draw?symbol=AAPL&model=rf")
    assert pred_resp.status_code == 200
    
    result = pred_resp.json()
    assert "label" in result
    assert "proba" in result
```

### 3. 測試覆蓋率

```bash
# 執行測試並生成覆蓋率報告
pytest --cov=. --cov-report=html tests/

# 查看覆蓋率報告
# htmlcov/index.html
```

**目標覆蓋率**：
- 核心業務邏輯：> 80%
- API 端點：> 70%
- 工具函式：> 60%

---

## 版本控制

### 1. Git 工作流

#### 1.1 分支策略（Git Flow）

```
main (生產分支)
  ├── develop (開發分支)
       ├── feature/add-index-loop (功能分支)
       ├── feature/improve-logging (功能分支)
       └── hotfix/fix-rate-limit (熱修復分支)
```

**分支規範**：
- `main` - 生產環境程式碼（僅接受來自 `develop` 或 `hotfix` 的合併）
- `develop` - 開發環境程式碼（整合最新功能）
- `feature/*` - 新功能開發
- `hotfix/*` - 緊急修復
- `release/*` - 發佈準備

#### 1.2 提交信息規範（Conventional Commits）

```
<類型>(<範圍>): <簡短描述>

<詳細描述>

<關聯 Issue>
```

**類型（Type）**：
- `feat` - 新功能
- `fix` - Bug 修復
- `docs` - 文檔更新
- `style` - 程式碼格式（不影響功能）
- `refactor` - 程式碼重構
- `test` - 測試相關
- `chore` - 建構工具或輔助工具變動

**範例**：
```
feat(api): 添加指數批量更新介面

- 實作 Index Loop 功能
- 支持 S&P 500 和 Nasdaq-100 指數
- 動態合併現有 CSV symbols

Closes #42
```

```
fix(predict): 修復特徵對齊時缺失列導致的例外

當新資料缺少訓練時使用的特徵時，自動填充爲 0。

Fixes #38
```

### 2. 程式碼審查（Code Review）

#### 2.1 審查清單

- [ ] 程式碼風格符合 PEP 8
- [ ] 函式有完整的類型標註
- [ ] 關鍵邏輯有註釋說明
- [ ] 例外處理完整（不吞例外）
- [ ] 添加了單元測試
- [ ] 測試覆蓋率不下降
- [ ] 無明顯效能問題
- [ ] 文檔已更新（如 README, API 文檔）

#### 2.2 審查流程

1. 開發者提交 Pull Request
2. CI 自動執行測試（pytest, lint）
3. 至少一名團隊成員審查程式碼
4. 修改反饋意見
5. 審查通過後合併到 `develop`
6. 定期從 `develop` 發佈到 `main`

---

## 效能最佳化

### 1. 程式碼層面最佳化

#### 1.1 避免重複計算

```python
# ❌ 重複計算中位數
for i in range(len(df)):
    df.loc[i, 'col'] = df['col'].median()

# ✅ 計算一次，複用結果
median = df['col'].median()
df['col'] = df['col'].fillna(median)
```

#### 1.2 使用向量化操作

```python
# ❌ 逐行循環
for i in range(len(df)):
    df.loc[i, 'ret'] = (df.loc[i, 'close'] / df.loc[i-1, 'close'] - 1) * 100

# ✅ pandas 向量化
df['ret'] = df['close'].pct_change() * 100
```

#### 1.3 延遲載入（Lazy Loading）

```python
# ✅ 僅在需要時載入模型
def predict(csv_path, model):
    if not hasattr(predict, '_cached_model'):
        predict._cached_model = joblib.load(model_path)
    return predict._cached_model.predict(X)
```

### 2. 資料庫與 I/O 最佳化

#### 2.1 批量讀寫

```python
# ❌ 逐條寫入
for symbol in symbols:
    df = build_data(symbol)
    df.to_csv(f"{symbol}.csv")

# ✅ 批量寫入
dfs = {symbol: build_data(symbol) for symbol in symbols}
for symbol, df in dfs.items():
    df.to_csv(f"{symbol}.csv")
```

#### 2.2 使用非同步 I/O

```python
# ✅ 非同步讀取多個檔案
async def read_csvs(paths):
    tasks = [asyncio.to_thread(pd.read_csv, p) for p in paths]
    return await asyncio.gather(*tasks)
```

---

## 安全規範

### 1. 敏感信息管理

```python
# ✅ 使用環境變數
API_KEY = os.getenv("API_KEY")

# ❌ 硬編碼敏感信息
API_KEY = "your-secret-key-12345"
```

### 2. 輸入驗證

```python
# ✅ 驗證用戶輸入
def validate_symbol(symbol: str) -> bool:
    if not symbol:
        return False
    if len(symbol) > 10:
        return False
    if not re.match(r'^[A-Z0-9]+$', symbol.upper()):
        return False
    return True

@app.get('/api/draw')
def draw(symbol: str):
    if not validate_symbol(symbol):
        return JSONResponse(
            {"error": "無效的股票程式碼"},
            status_code=400
        )
```

### 3. SQL 注入防護（未使用資料庫時忽略）

```python
# ✅ 使用參數化查詢
cursor.execute("SELECT * FROM stocks WHERE symbol = ?", (symbol,))

# ❌ 字符串拼接
cursor.execute(f"SELECT * FROM stocks WHERE symbol = '{symbol}'")
```

---

## 文檔規範

### 1. README 維護

**必須包含**：
- 專案簡介
- 快速開始（安裝與執行）
- API 文檔（主要端點）
- 配置說明（環境變數）
- 部署指南（Docker, K8s）
- 常見問題（FAQ）

### 2. API 文檔

**使用 FastAPI 自動生成**：
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`

**端點文檔範例**：
```python
@app.get('/api/draw', summary="執行股票預測", tags=["預測"])
def draw(
    model: str = Query("rf", description="模型類型（rf 或 lr）"),
    symbol: Optional[str] = Query(None, description="股票程式碼（如 AAPL）")
):
    """
    ## 功能說明
    對指定股票執行短期漲跌預測。

    ## 請求參數
    - **model**: 模型類型（預設 rf）
    - **symbol**: 股票程式碼（可選，預設使用主 CSV）

    ## 回應範例
    ```json
    {
      "label": "漲",
      "proba": 0.6523,
      "threshold": 0.55
    }
    ```
    """
```

### 3. 程式碼文檔（Docstring）

**必須編寫文檔字符串的場景**：
- 所有公開函式和方法
- 所有類別
- 複雜的內部函式（如涉及演算法）

---

## 持續整合/持續部署（CI/CD）

### 1. CI 流程

```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
      - name: Run tests
        run: pytest --cov=. tests/
      - name: Lint
        run: |
          pip install flake8
          flake8 . --max-line-length=120
```

### 2. CD 流程

```yaml
# .github/workflows/cd.yml
name: CD

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker build -t new_project:latest .
      - name: Push to registry
        run: |
          docker tag new_project:latest ghcr.io/user/new_project:latest
          docker push ghcr.io/user/new_project:latest
```

---

## 相關文檔

- [01_架構概覽.md](./01_架構概覽.md) - 系統架構與技術棧
- [02_資料模型.md](./02_資料模型.md) - 核心資料結構
- [03_業務規則.md](./03_業務規則.md) - 業務邏輯與特殊規則
- [04_術語詞彙.md](./04_術語詞彙.md) - 統一術語與命名約定
- [06_常見問題.md](./06_常見問題.md) - FAQ 與故障排查
